# Практична робота №6: Valgrind

## Завдання 
Побудуйте Valgrind Summary Table (таблицю), в яку включено тип помилки, приклад коду, вихід Valgrind та спосіб виправлення.

## Valgrind Summary Table

| **Тип помилки**            | **Приклад коду**                                                                                                                                       | **Вихід Valgrind**                                                                                                               | **Спосіб виправлення**                                                                                                           |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| **Memory Leak**             | ```c\nint *ptr = malloc(10 * sizeof(int));\n// Забули виклик free(ptr);\n```                                                                       | ```==1234== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1\n```                                                  | Використовувати `free(ptr);` після завершення використання пам'яті.                                                            |
| **Use of Uninitialized Memory** | ```c\nint x;\nprintf("%d", x);  // x не ініціалізовано\n```                                                                                           | ```==1234== Conditional jump or move depends on uninitialised value(s)\n```                                                     | Ініціалізувати змінну перед використанням: `int x = 0;`                                                                        |
| **Access to Freed Memory**  | ```c\nint *ptr = malloc(10 * sizeof(int));\nfree(ptr);\nprintf("%d", ptr[0]);\n```                                                                 | ```==1234== Invalid read of size 4\n==1234==    at 0x...: main (example.c:5)\n==1234==  Address 0x... was free'd\n```           | Не звертатися до пам'яті після її звільнення або присвоїти вказівнику значення `NULL` після виклику `free(ptr);`.             |
| **Double Free**             | ```c\nint *ptr = malloc(10 * sizeof(int));\nfree(ptr);\nfree(ptr);  // Двічі звільняємо пам'ять\n```                                                  | ```==1234== Double free or corruption (fasttop)\n==1234==    at 0x...: main (example.c:6)\n```                                 | Переконатися, що пам'ять звільняється тільки один раз і після цього вказівник ставиться в `NULL`.                             |
| **Invalid Write**           | ```c\nint *ptr = malloc(10 * sizeof(int));\nptr[10] = 5;  // За межами виділеного масиву\n```                                                      | ```==1234== Invalid write of size 4\n==1234==    at 0x...: main (example.c:6)\n==1234==  Address 0x... is 4 bytes after a block of size 40\n``` | Переконатися, що не виходимо за межі виділеної пам'яті.                                                                         |
| **Unaligned Memory Access** | ```c\nint *ptr = malloc(10 * sizeof(int));\nchar *char_ptr = (char*)ptr;\nprintf("%c", char_ptr[5]);\n```                                           | ```==1234== Unaligned access to 0x... of size 1\n==1234==    at 0x...: main (example.c:7)\n```                                 | Використовувати правильний тип даних для доступу до пам'яті або гарантувати, що доступ до пам'яті виконується через правильний тип. |
| **Mismatched malloc/free**  | ```c\nint *ptr = malloc(10 * sizeof(int));\nfree(ptr);\nfree(ptr); // Мismatch: неправильно звільняємо пам'ять\n```                                    | ```==1234== Invalid free() / double free\n==1234==    at 0x...: main (example.c:7)\n```                                        | Використовувати коректні функції звільнення пам'яті та уникати подвійного звільнення.                                           |
| **Heap Buffer Overflow**    | ```c\nint *ptr = malloc(10 * sizeof(int));\nptr[15] = 5;  // Перевищено межі масиву\n```                                                           | ```==1234== Invalid write of size 4\n==1234==    at 0x...: main (example.c:5)\n==1234==  Address 0x... is 20 bytes beyond a block of size 40\n``` | Переконатися, що доступ до пам'яті не перевищує виділений розмір.                                                                 |
