# Практична робота №2: Аналіз сегментів у виконуваних файлах ELF та управління пам'яттю

Практична робота присвячена дослідженню сегментів виконуваних файлів ELF, їх розташуванню в пам'яті, впливу ініціалізації змінних на розмір файлу та управлінню пам'яттю в процесах під час виконання програми.

## Зміст

1. [Момент закінчення time_t](#момент-закінчення-time_t) 
2. [Аналіз сегментів](#аналіз-сегментів)
3. [Дослідження розташування стека та сегментів пам'яті в системі](#дослідження-розташування-стека-та-сегментів-пам'яті-в-системі)
4. [Дослідження стека за допомогою gstack та GDB](#дослідження-стека-за-допомогою-gstack-та-GDB)
5. [Використання вершини стека замість лічильника команд (IP)](#використання-вершини-стека-замість-лічильника-команд-(IP))
6. [Завантажувач ELF-файлів](#завантажувач-ELF-файлів)

---
## 1. Момент закінчення time_t
На 32-бітних системах тип `time_t` займає 4 байти, що призводить до переповнення значення 19 січня 2038 року, а на 64-бітних системах `time_t` має 8 байтів і може зберігати значення часу на мільярди років у майбутньому. Програма поступово збільшує `time_t`, доки не станеться переповнення, після чого виводить його максимальне значення та дату переповнення. 

## 2. Аналіз сегментів

### "Hello, World!"
Ця програма просто виводить "Hello, World!". Її розмір відображає лише базову структуру ELF-файлу, включаючи текстовий сегмент (text), сегмент даних (data) і сегмент BSS.

#### Код:
```
    #include <stdio.h>

    int main() {
    printf("Hello, World!\n");
    return 0;
    }
```
#### Компіляція та аналіз:
```
    gcc -Wall task2.1.c -o task2.1
    ls -l task2.1
    size task2.1
```

### Додавання глобального масиву (без ініціалізації)
Глобальний масив без ініціалізації потрапляє в сегмент BSS, який не зберігається у виконуваному файлі, а лише визначає область пам’яті під час виконання.

#### Код:
```
    #include <stdio.h>

    int arr[1000];
    
    int main() {
        printf("Hello, World!\n");
        return 0;
    }
```
#### Компіляція та аналіз:
```
    gcc -Wall task2.2.c -o task2.2
    ls -l task2.2
    size task2.2
```
### Додавання ініціалізації масиву
Коли додається початкове значення, масив переходить з сегмента BSS у сегмент даних (data), який зберігається у виконуваному файлі.

#### Код:
```
    #include <stdio.h>

    int arr[1000] = {1}; 
    
    int main() {
        printf("Hello, World!\n");
        return 0;
    }
```
#### Компіляція та аналіз:
```
    gcc -Wall task2.3.c -o task2.3
    ls -l task2.3
    size task2.3
```

### Локальні масиви у функціях
`local_arr1[1000]` створюється в стеку, тому не впливає на розмір ELF.

`static local_arr2[1000] = {1};` потрапляє у сегмент даних (data), збільшуючи файл.

#### Код:
```
    #include <stdio.h>

    void func() {
        int local_arr1[1000]; 
        static int local_arr2[1000] = {1};  
    }
    
    int main() {
        printf("Hello, World!\n");
        func();
        return 0;
    }
```
#### Компіляція та аналіз:
```
    gcc -Wall task2.4.c -o task2.4
    ls -l task2.4
    size task2.4
```

### Вплив оптимізації та налагодження

#### Компіляція з налагодженням:
```
    gcc -Wall task2.1.c -g -o task2.1_debug
    ls -l task2.1_debug
    size task2.1_debug
```
Компіляція з -g додає відлагоджувальну інформацію, але не змінює сегменти text, data, bss.
#### Компіляція з оптимізацією:
```
    gcc -Wall task2.1.c -O3 -o task2.1_opt
    ls -l task2.1_opt
    size task2.1_opt
```
Оптимізація -O3 може зменшити або змінити код у text, але не впливає на data і bss.

## 3. Дослідження розташування стека та сегментів пам'яті в системі
- Адреса стека змінюється після виклику expand_stack(), оскільки в ній виділяється велике локальне сховище.

- Адреса купи розширюється, бо пам'ять виділяється через malloc().

- Сегмент коду залишається статичним.

- Сегменти BSS і Data не змінюються після старту програми.
### Результат:
```
    Stack top is near: 0x7ffc1234abcd
    Heap starts from:  0x5555557592a0
    Data segment (initialized global_var): 0x60104c
    BSS segment (uninitialized_var): 0x601050
    Data segment (static_var): 0x601054
    Code segment (main function): 0x4005d6
    After expanding stack, top is near 0x7ffc12347890
```

## 4. Дослідження стека за допомогою gstack та GDB
### Опис:
`gstack` забезпечує швидкий перегляд стеку викликів працюючого процесу, тоді як `GDB` надає більш детальний аналіз із можливістю перегляду змінних, зміни їх значень, встановлення точок зупину та покрокового виконання програми. `gstack` зручний для швидкої діагностики, а `GDB` — для глибокого налагодження.

## 5. Використання вершини стека замість лічильника команд (IP)
#### Код:
```
    #include <stdio.h>
    #include <setjmp.h>
    
    jmp_buf stackTop;
    
    void lostWithoutIP() {
        printf("Oh no! Where am I? I don't know where to return...\n");
        longjmp(stackTop, 1);
    }
    
    int main() {
        if (setjmp(stackTop) == 0) {
            printf("Sending a function call...\n");
            lostWithoutIP();
        } else {
            printf("Oops! We returned to the wrong place!\n");
        }
        printf("Program exited safely! (But that was weird)\n");
        return 0;
    }
```
Неможливо повністю обійтися без лічильника команд (IP), використовуючи тільки вершину стека, оскільки стек лише зберігає адреси повернення, але не контролює порядок виконання команд. У процесі виклику функцій IP визначає, яка наступна інструкція має бути виконана, тоді як стек лише тимчасово зберігає адреси повернення для коректного відновлення виконання після завершення виклику. У представленій програмі використання `setjmp` і `longjmp` демонструє проблему: при виклику `longjmp` стекова структура не гарантує правильне повернення до очікуваного місця, що може призвести до непередбачуваних результатів. Таким чином, IP необхідний для коректного управління потоком виконання програми.

## 6. Завантажувач ELF-файлів
### Перевірка аргументів командного рядка
- Програма очікує на один аргумент — шлях до ELF-файлу.
- Якщо аргумент не передано, виводиться повідомлення про правильний синтаксис використання, і виконання завершується.

### Відкриття ELF-файлу та читання вмісту
- Файл відкривається в режимі читання (`fopen`).
- Визначається його розмір (`fseek` + `ftell`), після чого створюється буфер (`malloc`), куди зчитується весь вміст ELF-файлу.

### Перевірка, чи це дійсно ELF-файл
- Виконується перевірка заголовку ELF (`is_image_valid`), яка порівнює перші байти файлу зі стандартним магічним числом ELF (`ELFMAG`).
- Якщо файл не є ELF-зображенням, виводиться повідомлення `"Invalid ELF image"` і виконання припиняється.

### Виділення пам’яті для виконання ELF-коду
- Виділяється блок пам’яті (`mmap`) для завантаження ELF-зображення з правами читання (`PROT_READ`), запису (`PROT_WRITE`) та виконання (`PROT_EXEC`).
- Якщо пам'ять не вдалося виділити, програма виводить `"Memory allocation error"` і завершується.

### Обробка програмних заголовків ELF-файлу
- Програма проходить по всіх заголовках сегментів (`Elf32_Phdr`) і шукає сегменти з типом `PT_LOAD`, які потрібно завантажити в пам’ять.
- Дані сегмента копіюються в новий виділений блок пам’яті.
- Якщо сегмент є лише для читання, на нього встановлюється обмеження (`mprotect`).
- Якщо сегмент є виконуваним, йому надаються права виконання.

### Передача управління виконуваному файлу
- Визначається точка входу (`e_entry`) ELF-файлу.
- Програма змінює потік виконання, викликаючи завантажений ELF-код як функцію.

### Завершення програми
- Після завершення виконання ELF-файлу, пам’ять звільняється.
